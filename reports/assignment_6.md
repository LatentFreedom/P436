Nick Palumbo
Assignment 6 report

## FUTURE_EXCLUSIVE implementation

For FUTURE_EXCLUSIVE was a maximum of 2 threads allowed. The first thread will set the value of the future and the other will get the value of the future. Within the shell command code for xsh_producer_consumer.c the flag -f will run the future code to test futures. A future structure is created nameed f_exclusive to test the FUTURE_EXCLUSIVE functionality. This structre is used in 2 threads that call future_cons and future_prod. The call to future_prod has 2 arguments instead of 1 like the future_cons because it is passing in a value to be produced which will then be consumed by the future consumer thread. 

future_prod will call future_set and pass in the future and the value to be set for the future. future_set will check to see if the state of the future is either FUTURE_EMPTY or FUTURE_WAITING. If either of these states are set then the value will be set and the future state will change to FUTURE_READY. The change of state to FUTURE_READY allows the future within the consumer thread to notice that there is now a value within the future. If the future state is FUTURE_EMPTY we know that the consumer has not made it to the future yet in future_get. future_get would change the future state to waiting if FUTURE_EMPTY is encountered. Now if the future state is FUTURE_WAITING we know that the consumer has attempted to get a value from the future and we also know that because of this the consumer process has been suspended and put on the suspended process list. With this knowledge we will also have the pid of the consumer process that is suspended. The future set function will now set the value of the future, change the state to FUTURE_READY, and then resume the consumer process so it can continue running.

future_cons only takes a future as an argument. The function will call future_get to see if the future has a value. Within future_get the future state value is checked. If the future has the state FUTURE_READY then there is a value waiting within the future. If the future state is FUTURE_EMPTY then we know that there is no value set so the future state changes to FUTURE_WAITING. Now that the future has the state FUTURE_WAITING, the process state should be changed to PR_SUSP so that the process does not continue to run. The consumer process is then suspended with the suspend call on it's pid with getpid(). However, just before suspending the process the process id must be stored within the future pid so that when the producer places the value within the future it can also resume the process of the consumer given that pid stored.

## FUTURE_SHARED implementation